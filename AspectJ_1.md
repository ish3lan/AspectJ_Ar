![شالين](https://thearthand.files.wordpress.com/2011/04/coloured-glass-mosaic-019x-e1413458818342.jpg)

#AspcetJ 
أهلاً بك،  
هذه التدوينة تتحدث عن [نموذج أو نمط برمجي](https://ar.wikipedia.org/wiki/%D9%86%D9%85%D8%B7_%D8%A8%D8%B1%D9%85%D8%AC%D8%A9) ([Prgoramming Paradigm](https://en.wikipedia.org/wiki/Programming_paradigm)) يسمى بـ [Aspect Oriented Programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming) أو [البرمجة جانبية المنحى](https://ar.wikipedia.org/wiki/%D8%A8%D8%B1%D9%85%D8%AC%D8%A9_%D8%AC%D8%A7%D9%86%D8%A8%D9%8A%D8%A9_%D8%A7%D9%84%D9%85%D9%86%D8%AD%D9%89) وكيفية تطبيقه في المشاريع المكتوبة بلغة جافا عن طريق استعمال إضافة [AspectJ](https://en.wikipedia.org/wiki/AspectJ) .

----

### البرمجة جانبية المنحى:
هذا النمط البرمجي يهتم بفصل بعض الأجزاء من شفرة المشروع *ولنتفق على تسميتها **اهتمامات*** ،  مثل:
  
- تسجيل الأحداث logging.
- الأمان.
- متابعة الأداء.

ربما لاحظت أن هذه النقاط يجمع بينها عامل مشترك، وهو أن تنفيذها يتطلب كتابة الشفرة في أماكن كثيرة متفرقة، فمثلاً تسجيل الأحداث سوف تجده منتشراً في كل ميثود تقوم بوظيفة ذات أهمية، أيضاً بالنسبة لمتابعة الأداء نحتاج للقياس في أماكن كثيرة لمعرفة الجزء المؤثر بشكل أكبر على مستوى الأداء.   

**حسناً ما المشكلة في ذلك؟**
مع مرور الوقت وتطور المشروع ستتراكم هذه الشفرات المنتشرة لتؤثر على سرعة فهم وتعديل أجزاء من المشروع وتقلل من مستوى [التجانس داخل مكوناته](https://en.wikipedia.org/wiki/Cohesion_(computer_science)). فمثلاً عند تغيير صياغة السجل log نحتاج لتعديل ملفات كثيرة من المشروع، وهذا بجانب أنه مضيع للوقت والجهد، فهو أيضاً مظنّة الخطأ.
بهذا نستطيع أن نقول أن تقسيم المشروع إلى وحدات منفصلة يقدم أكثر من حل:

- سهولة التغيير والإضافة لأجزاء من المشروع، لأن انفصالها عن الأجزاء الأخرى يقلل من احتمالية حصول مشاكل.
- إمكانية إعادة استخدام أجزاء من المشروع في مشاريع قادمة.
- إزالة الشفرات المتكررة في المشروع وجعلها في مكان واحد مما يسهل تعديلها فيما بعد.

 هنا مثالين من مشروع tomcat :  
**الأول**: مثال على *اهتمام* في المشروع متعلق بـ class loading وهو مقسم تقسيماً جيداً  :  

![good modularity](http://images.slideplayer.com/32/10001920/slides/slide_3.jpg)
    

**الثاني**: مثال على *اهتمام* آخر وهو التسجيل logging وهو موزع في كل أجزاء المشروع :   
![not so good modualrity
](http://images.slideplayer.com/32/10001920/slides/slide_4.jpg)  
  
حسناً **ما هو الحل المقترح؟**  
تعتبر البرمجة جانبية المنحى من أذكى الحلول المقدمة لتقسيم المشروع إلى مكونات منفصلة تقريباً ، فمع أثره الكبير لا يحتاج هذا النمط البرمجي الكثير من الجهد والوقت لتعلمه.
وأرجو أن يكون الطرح في هذه التدوينة وما بعدها يعزز الفهم ويدعوك للبحث والاستكشاف.

قبل أن نبدأ في تفصيلات AspectJ ربما من المناسب أن نرى مثالاً بسيطاً يوضح جانباً من فوائد هذه الإضافة:	
لنفترض أن لدينا هذه المتطلبات:  

----
 لدينا برنامج للرسم ونريد منك أن تزودنا بالكلاسات التالية:  
  `Square`, `Circle`, `Triangle` وغيرها من الأشكال التي ستمكن الرسام من الرسم في برنامجنا، مع مراعاة الآتي:

- سجل كل محاولة إضافة أو تعديل شكل.
- لا يمكن تعديل الشكل إلا من الشخص الذي أنشأه.
- أي تعديل لخصائص الشكل يجب أن يظهر مباشرة في لوح الرسم في البرنامج.

----

سنجد أن محاولة تسجيل كل تعديل في الأشكال يستلزم وجود شفرة داخل كل ميثود تعدل حجم أو لون أو موقع الشكل، مما يعني وجود الكثير من الشفرات الموجودة في ملف الشكل *class* ليس لها علاقة به وإنما لها علاقة بالمشروع، وهذا يصعّب إعادة استعمال الشكل في مشاريع أخرى :

    Public Shape drawCircle(...)
    {
		if (!artist.isAuthorized())
		{
			throw NotAuthorizedDrawerException();
		}
		Logger.log("Artist : " + artist + "started drawing a Circle with attributes: " + circle.attrs);
		
		
		//----- Drawing Circle related logic -----
	
		
		Logger.log("Artist : " + artist + "finished drawing a Circle with attributes: " + circle.attrs);

		drawingBoard.updateShape(circle.id);
    }
ربما لا تكون الشفرة منطقية بحكم أنها جزء من كلاس كامل، لكن يتضح لنا بوضوح كمية الشفرات المضافة لكل ميثود والتي سوف تتكرر في كل كلاس يمثل شكلاً من الأشكال المطلوبة.  

مع استعمال AspectJ بإمكاننا كتابة شفرات **أنظف** كما في المثال:

    public Shape drawCircle(..)
    {
	//----- Drawing Circle related logic -----
	}

نعم، كل جزء يفطي اهتماماته فقط، وفي مكان واحد في المشروع نضيف هذه الشفرة Aspect لتقوم بكل الجهد الذي بذلناه في المثال السابق :  

    public aspect DrawingAspect
    {
		pointcut drawingShape() : excution(* * *.draw*(..));
	
		around() : drawingShape()
		{
			//--- do the logic before excuting any method starting with drawXXX()---
			//--- 	e.g validate, log something

			proceed();

			//--- do the logic after excuting any method starting with drawXXX()---		
		}
	}

قبل تنفيذ أي ميثود، سوف تقوم AspectJ بتنفيذ بعض الشفرات الموجودة في مكان ما ثم تبدأ تنفيذ الميثود.  
ربما لا يكون المثال مفهوماً بشكل كامل، لكن مع استمرار متابعتك لهذه السلسة ستصبح الأمثلة أقرب وأبسط.
### AspectJ

كما ذكرنا سابقاً، AspectJ هي اضافة للغة جافا وحتى يمكن الاستفادة من الاضافة يحتاج أن نقوم بعملية ال[كومبايليشن](https://en.wikipedia.org/wiki/Compiler)  عن طريق كومبايلر يدعم هذه الإضافة وهو [`ajc` ](https://eclipse.org/aspectj/doc/next/devguide/ajc-ref.html). الشيء الجيد هو أن بيئة التطوير Eclipse تدعم AspectJ وتبسط الكثير من التعقيدات المصاحبة للإضافة، بإمكانك المواصلة في [شرح تثبيت AspectJ على بيئة Eclipse](https://eclipse.org/aspectj/) وربما أعود لكتابته بالعربية فيما بعد.

**ماذا بعد؟**  
كانت هذه مقدمة بسيطة جداً ومهمة قبل أن نبدأ في تفصيل مكونات الإضافة AspectJ وفي التدوينة القادمة نبدأ بمكونات الإضافة ونطرح أمثلة تظهر فائدة كل مكوّن بشكل أوضح وأخيراً نقطف ثمرة السلسة بتطبيق الإضافة على نمطي تصميم مشهورين.

**شكراً لقراءتك :).**


----
###### [@imsh3lan](http://www.twitter.com/imsh3lan)
